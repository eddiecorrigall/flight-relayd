// jasmine unit testing

var http = require('http');
var async = require('async');
var shortid = require('shortid');

var SSEClient = require('sse').Client;
var SSEServices = require('../').Services;

require('../').debug = false;

http.globalAgent.maxSockets = 100;

var nextPort = 8080;

describe('test peer join event', function () {

	var sseServices = null;
	var joinSpy = null;
	
	beforeEach(function (done) {

		joinSpy = jasmine.createSpy('join' + nextPort);
		
		sseServices = new SSEServices(nextPort);
		sseServices.on('start', function () {
			sseServices.sseChannel.on('join', joinSpy);
			var reqOptions = {
				port: sseServices.httpPort,
				host: 'localhost',
				path: '/sse'
			};
			var req = http.request(reqOptions, function (res) {
				expect(res.statusCode).toBe(200);
				done();
			});
			req.end();
		});

		nextPort++;
	});
	
	afterEach(function () {
		sseServices.emit('stop');
	});

	// ...

	it('has correctly named spy', function () {
		expect(joinSpy.and.identity()).toEqual('join' + sseServices.httpPort);
	});

	it('will emit the join event', function () {
		expect(joinSpy).toHaveBeenCalled();
	});

	it('will emit the join event only once', function () {
		expect(joinSpy.calls.count()).toEqual(1);
	});

	it('will pass a message dispatch function as argument to join event', function () {
		// sseServices.sseChannel.on('join', function (pm) {});
		expect(typeof joinSpy.calls.mostRecent().args[0]).toBe('function');
	});

	it('will increment the peer count to one', function () {
		expect(sseServices.sseChannel.peers).toBe(1);
	});
});

describe('test peer exit event', function () {

	var sseServices = null;
	var exitSpy = null;

	beforeEach(function (done) {

		exitSpy = jasmine.createSpy('exit' + nextPort);

		sseServices = new SSEServices(nextPort);
		sseServices.on('start', function () {
			sseServices.sseChannel.on('exit', exitSpy);
			var reqOptions = {
				port: sseServices.httpPort,
				host: 'localhost',
				path: '/sse'
			};
			var req = http.request(reqOptions, function (res) {
				expect(res.statusCode).toBe(200);
				sseServices.emit('stop');
				done();
			});
			req.end();
		});

		nextPort++;
	});
	
	afterEach(function () {
	});

	// ...

	it('has correctly named exit spy', function () {
		expect(exitSpy.and.identity()).toEqual('exit' + sseServices.httpPort);
	});

	it('will emit the exit event', function () {
		expect(exitSpy).toHaveBeenCalled();
	});

	it('will emit the exit event only once', function () {
		expect(exitSpy.calls.count()).toEqual(1);
	});

	it('will pass a message dispatch function as argument to exit event', function () {
		// sseServices.sseChannel.on('exit', function (pm) {});
		expect(typeof exitSpy.calls.mostRecent().args[0]).toBe('function');
	});

	it('will increment the peer count to zero', function () {
		expect(sseServices.sseChannel.peers).toBe(0);
	});
});

// * Test broadcast for 1 to N peers; determine that broadcast messages are identical and in-order
// 	- Connect 2 or more peers to server
// 	- Using broadcast event, send same message to all peers
// 	- Test that peers receive the same message

describe('determine that broadcast messages are identical and delivered in the same order', function () {

	var PEERS = http.globalAgent.maxSockets;
	var MESSAGES = 2*PEERS;

	var sseServices = null;
	var ssePeerReceived = [];

	beforeEach(function (done) {

		sseServices = new SSEServices(nextPort);
		sseServices.on('start', function () {
			var reqOptions = {
				port: sseServices.httpPort,
				host: 'localhost',
				path: '/sse'
			};
			var asyncTasks = [];
			for (var p = 0; p < PEERS; p++) {
				(function (x) {
					asyncTasks.push(function (asyncTaskDone) {
						var req = http.request(reqOptions, function (res) {
							expect(res.statusCode).toBe(200);
							res.setEncoding('utf8');
							res.on('data', function (chunk) {
								if (!ssePeerReceived[x]) {
									ssePeerReceived[x] = [];
								}
								ssePeerReceived[x].push(chunk);
							});
							asyncTaskDone();
						});
						req.end();
					});
				})(p);
			}
			async.parallel(asyncTasks, function () {
				// Send messages
				for (var m = 0; m < MESSAGES; m++) {
					sseServices.sseChannel.emit('broadcast', 'message' + m, m, {});
				}
				sseServices.emit('stop');
				// Wait a second until messages are dispatched, and
				// the connections are closed
				setTimeout(done, 1000);
			});
		});
		
		nextPort++;
	});

	afterEach(function () {
	});

	// ...

	it('sent messages to all peers', function () {
		for (var p = 0; p < PEERS; p++) {
			expect(ssePeerReceived[p] instanceof Array).toBe(true);
			for (var m = 0; m < MESSAGES; m++) {
				expect(typeof ssePeerReceived[p][m]).toBe('string');
			}
		}
	});

	it('sent the same messages in the same order across all peers', function () {
		for (var m = 0; m < MESSAGES; m++) {
			for (var p = 1; p < PEERS; p++) {
				expect(ssePeerReceived[0][m]).toBe(ssePeerReceived[p][m]);
			}
		}
	});
});

// * Test server to peer join, broadcast, exit and messaging
// 	- Connect 2 or more peers to server
// 	- Send them unique messages via pm function
// 	- Test that each peer receives their associated message

describe('determine that peers can be sent custom and unique messages and be delivered in the same order', function () {

	var PEERS = http.globalAgent.maxSockets;
	var MESSAGES = 2*PEERS;

	var sseServices = null;
	var ssePeerMessages = []; // Expected
	var ssePeerReceived = []; // Observed

	// Pre-generate all messages
	for (var p = 0; p < PEERS; p++) {
		ssePeerMessages[p] = [];
		for (var m = 0; m < MESSAGES; m++) {
			var message = ['message', shortid.generate()].join('_');
			ssePeerMessages[p].push(message);
		}
	}

	beforeEach(function (done) {

		sseServices = new SSEServices(nextPort);
		sseServices.on('start', function () {
			// Send peers messages
			var pp = 0;
			sseServices.sseChannel.on('join', function (pm) {
				expect(pp).toBeLessThan(PEERS);
				for (var m = 0; m < MESSAGES; m++) {
					pm(ssePeerMessages[pp][m], m, {});
				}
				pp++;
			});
			// Connect peers
			var reqOptions = {
				port: sseServices.httpPort,
				host: 'localhost',
				path: '/sse'
			};
			var asyncTasks = [];
			for (var p = 0; p < PEERS; p++) {
				(function (x) {
					asyncTasks.push(function (asyncTaskDone) {
						var req = http.request(reqOptions, function (res) {
							expect(res.statusCode).toBe(200);
							res.setEncoding('utf8');
							res.on('data', function (chunk) {
								if (!ssePeerReceived[x]) {
									ssePeerReceived[x] = [];
								}
								var parts = chunk.split(':');
								if (parts[0] !== 'event') return;
								var message = parts[1].trim();
								ssePeerReceived[x].push(message);
							});
							asyncTaskDone();
						});
						req.end();
					});
				})(p);
			}
			async.parallel(asyncTasks, function () {
				// Wait a second until messages are dispatched, and
				// the connections are closed
				setTimeout(done, 1000);
			});
		});
		
		nextPort++;
	});

	afterEach(function () {
		sseServices.emit('stop');
	});

	it('sent messages to all peers', function () {
		for (var p = 0; p < PEERS; p++) {
			expect(ssePeerReceived[p] instanceof Array).toBe(true);
			for (var m = 0; m < MESSAGES; m++) {
				expect(typeof ssePeerReceived[p][m]).toBe('string');
			}
		}
	});

	it('sent custom messages to the correct peer in the correct order', function () {
		for (var m = 0; m < MESSAGES; m++) {
			for (var p = 0; p < PEERS; p++) {
				expect(ssePeerMessages[p][m]).toBe(ssePeerReceived[p][m]);
			}
		}
	});
});
