var _ = require('lodash');

var fs = require('fs');
var util = require('util');
var http = require('http');
var assert = require('assert');
var events = require('events');

var SSE = require('sse');

function getIP (req) {
	return req.headers['x-forwarded-for'] || req.connection.remoteAddress;
}

// TODO: make SSEChannel.on('error', ...) more useful by passing event information

module.exports.debug = false;

// ...

var SSEChannel = function (sseServer) { // SSEChannel class
	this.peers = 0;
	// ...
	var self = this;
	// ...
	sseServer.on('connection', function (peer) {
		assert(peer instanceof SSE.Client, 'Argument passed must be an instance of SSE.Client');
		// Construct new broadcast listener from peer
		// This is a private channel to a peer
		var dispatchEvent = function (eventField, eventId, eventData) {
			// Validate input
			if (!_.isString(eventField)) {
				if (module.exports.debug) console.error('SSE Event Field - must be string', eventField);
				//self.emit('error', 'SSE Event Field - must be string');
				return;
			}
			eventId = parseInt(eventId);
			if (!_.isNumber(eventId)) {
				if (module.exports.debug) console.error('SSE Event ID - must be a number', eventId);
				//self.emit('error', 'SSE Event ID - must be a number');
				return;
			}
			if (isNaN(eventId)) {
				if (module.exports.debug) console.error('SSE Event ID - must be a number and not NaN', eventId);
				//self.emit('error', 'SSE Event ID - must be a number and not NaN');
				return;
			}
			// ...
			switch (typeof eventData) {
				case 'object': { eventData = JSON.stringify(eventData); } break;
				case 'number': { eventData = '' + eventData; } break;
				case 'string': break;
				default: {
					if (module.exports.debug) console.error('SSE Event Data - must be an object, number or string', eventData);
					//self.emit('error', 'SSE Event Data - must be an object, number or string');
					return;
				} break;
			}
			peer.send({
				'event': eventField,
				'id': eventId,
				'data': eventData
			});
			// ...
			if (module.exports.debug) {
				console.log('broadcast', eventId, eventField, eventData);
			}
		}
		// ...
		self.peers++;
		// ...
		var ip = getIP(peer.req); // DEBUG only
		// ...
		var peerClosed = false;
		peer.on('close', function () {
			if (peerClosed) return; // Event called already
			peerClosed = true;
			// ...
			self.peers--;
			// ...
			if (module.exports.debug) {
				console.log('exit', ip);
			}
			self.emit('exit', dispatchEvent); // Inform channel exit listeners
			self.removeListener('broadcast', dispatchEvent); // Remove peer from broadcast
		});
		// When the SSE Server close event is dispatched, dispatch all SSE.Client close events
		sseServer.on('close', function () {
			peer.emit('close');
		});
		// Add to broadcast listeners
		// Anyone who emits a broadcast event can reach this peer, and thus all others
		self.addListener('broadcast', dispatchEvent);
		// Inform channel join listeners
		// Pass the dispatchEvent function to join listeners so this peer can be sent private messages
		if (module.exports.debug) {
			console.log('join', ip);
		}
		self.emit('join', dispatchEvent);
	});
}

util.inherits(SSEChannel, events.EventEmitter); // SSEChannel class extends events.EventEmitter

// ...
var SSEServices = function (httpPort, httpServer) { // SSEServices class
	var self = this;
	// ...
	var htmlPath = process.cwd() + '/index.html';
	if (module.exports.debug) {
		console.log('HTML path', htmlPath);
	}
	// ...
	this.sseChannel = undefined;
	this.httpPort = httpPort || process.env.PORT || 8181;
	this.httpServer = httpServer || http.createServer(function(req, res) {
		if (req.headers.accept === 'text/event-stream') return;
		fs.exists(htmlPath, function (exists) {
			if (exists) {
				res.writeHead(200, { 'Content-Type': 'text/html' });
				fs.createReadStream(htmlPath).pipe(res);
				return;
			}
			res.end('placeholder');
		});
	});
	// ...
	this.httpServer.listen(this.httpPort, function () {
		self.sseServer = new SSE(self.httpServer);
		self.sseChannel = new SSEChannel(self.sseServer);
		self.on('stop', function () {
			[self.sseChannel, self.sseServer, self.httpServer].map(function (service) {
				service.emit('close');
			});
		});
		self.emit('start');
	});
}

util.inherits(SSEServices, events.EventEmitter); // SSEServices class extends events.EventEmitter

// ...

module.exports.Channel = SSEChannel;
module.exports.Services = SSEServices;

/* ##### Example ##### 

var httpApp = express();
var httpServer = http.createServer(httpApp);

httpApp.get('/print', function (req, res) {
	res.end('Hello world!');
});

httpApp.use(express.static('./www'));

var sseServices = new SSEServices(8080, httpServer);

sseServices.on('start', function () {
	var sseStream = function () {
		var eventField = 'msg';
		var eventId = 123;
		var eventData = { 'special': 666 };
		sseServices.sseChannel.emit('broadcast', eventField, eventId, eventData);
	}
	setInterval(sseStream, 500);
});
sseServices.sseChannel.on('join', function (pm) {
	pm('hello', 1, {});
});
sseServices.sseChannel.on('exit', function (pm) {
	pm('goodbye', 999, {});
});
sseServices.sseChannel.on('error', function (msg) {
	console.error(msg);
});

##### ##### ##### ##### ##### */